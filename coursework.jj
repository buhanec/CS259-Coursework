PARSER_BEGIN(CS259Parser)
import java.util.*;

public class CS259Parser {
    public static void main(String[] args) {
        CS259Parser parser = new CS259Parser(System.in);
        try {
            parser.Program();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

class Function implements Callable {
    public final String name;
    public final String argument;
    public final Callable expr;

    public Function(String name, String argument, Callable expr) {
        this.name = name;
        this.argument = argument;
        this.expr = expr;
    }

    public int call(int arg) {
        return expr.call(arg);
    }

    public String toString() {
        return name+"("+argument+"):="+expr;
    }
}

class Number implements Callable {
    public final int value;

    public Number(String value) {
        this.value = Integer.parseInt(value);
    }
    public Number(int value) {
        this.value = value;
    }

    public int call(int arg) {
        return value;
    }

    public String toString() {
        return Integer.toString(value);
    }
}

class Argument implements Callable {
    public final String name;

    public Argument(String name) {
        this.name = name;
    }

    public int call(int arg) throws Exception {
        if (name == Functions.current.argument) {
            throw new Exception("Incorrect argument name \""+name+"\" for function \""+Functions.current.name+"\" (expected \""+Functions.current.argument+"\")");
        }
        return arg;
    }

    public String toString() {
        return name;
    }
}

class Call implements Callable {
    public final String function;
    public final Callable argument;

    public Call(String function, Callable argument) {
        this.function = function;
        this.argument = argument;
    }

    public int call(int arg) throws Exception {
        return Functions.table.get(function).call(arg);
    }

    public String toString() {
        return function+"("+argument+")";
    }
}

class Product implements Callable {
    public final Callable factor1;
    public final Callable factor2;

    public Product(Callable factor1, Callable factor2) {
        this.factor1 = factor1;
        this.factor2 = factor2;
    }

    public int call(int arg) throws Exception {
        return factor1.call(arg)*factor2.call(arg);
    }

    public String toString() {
        return "("+factor1+"*"+factor2+")";
    }
}

class Sum implements Callable {
    public final Callable summand1;
    public final Callable summand2;

    public Sum(Callable summand1, Callable summand2) {
        this.summand1 = summand1;
        this.summand2 = summand2;
    }

    public int call(int arg) throws Exception {
        return summand1.call(arg)+summand2.call(arg);
    }

    public String toString() {
        return "("+summand1+"+"+summand2+")";
    }
}

class Functions {
    public static HashMap<String, Function> table = new HashMap<String, Function>();
    public static HashSet<String> calls = new HashSet<String>();
    public static Function current = null;
}

PARSER_END(CS259Parser)

/** Tokens */
TOKEN :
{
        < EOL   : ";" ( "\r" | "\n" | "\r\n" ) >
    |   < DEF   : "DEF" >
    |   < MAIN  : "MAIN" >
    |   < FUNC  : ( <UPPER> )+ >
    |   < ARG   : ( <LOWER> )+ >
    |   < NUM   : ( <DIGIT> )+ >
    |   < PLUS  : "+" >
    |   < TIMES : "*" >
    |   < LPAR  : "(" >
    |   < RPAR  : ")" >
    |   < LANG  : "{" >
    |   < RANG  : "}" >
    |   < S     : " " >
}
TOKEN :
{
        < #DIGIT : ["0"-"9"] >
    |   < #UPPER : ["A"-"Z"] >
    |   < #LOWER : ["a"-"z"] >
}

void Program() : { Function f; }
{
    ( f = Def() { Functions.table.put(f.name, f); }
    )* <EOF> {
        for (String n: Functions.table.keySet()) {
            String fn = Functions.table.get(n).toString();
            System.out.println(fn);
        }
        System.out.println("Done");
    }
}

Function Def() : { Token f, a = null; Callable e; }
{
    <DEF> <S> ( ( f = <MAIN> ) | ( f = <FUNC> <S> a = <ARG> ) ) <S> <LANG> <S> e = Sums(a) <S> <RANG> <S> <EOL>
    {
        // argument check?
        return new Function(f.image, (a == null ? null : a.image), e);
    }
}

Callable Nullnary(Token a) : { Token f; Callable e; }
{
        <NUM> { return new Number(token.image); }
    |   <ARG> {
            if (!token.image.equals(a.image)) {
                throw new ParseException("Incorrect argument \"" + token.image + "\" (expected \"" + a.image + "\") at line " + token.beginLine + ", column " + token.beginColumn + ".");
            }
            return new Argument(token.image);
        }
    |   f = <FUNC> <LPAR> e = Sums(a) <RPAR> { return new Call(f.image, e); }
}

Callable CreateProduct(Token a, Callable p) : { Callable f; }
{
    ( <TIMES> f = Nullnary(a) { p = new Product(p, f); }
    )* { return p; }
}

Callable Products(Token a) : { Callable e; }
{
    e = Nullnary(a) e = CreateProduct(a, e) { return e; }
}

Callable CreateSum(Token a, Callable s) : { Callable e; }
{
    ( <PLUS> e = Products(a) { s = new Sum(s, e); }
    )* { return s; }
}

Callable Sums(Token a) : { Callable e; }
{
    e = Products(a) e = CreateSum(a, e) { return e; }
}
